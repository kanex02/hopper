package nz.ac.canterbury.seng302.tab.service.challenge;

import nz.ac.canterbury.seng302.tab.entity.UserEntity;
import nz.ac.canterbury.seng302.tab.entity.challenge.Challenge;
import nz.ac.canterbury.seng302.tab.entity.challenge.ChallengeCompletionStatus;
import nz.ac.canterbury.seng302.tab.repository.UserRepository;
import nz.ac.canterbury.seng302.tab.repository.challenge.ChallengeRepository;
import nz.ac.canterbury.seng302.tab.service.notification.ChallengeSharedEvent;
import nz.ac.canterbury.seng302.tab.service.notification.EventEmitter;
import nz.ac.canterbury.seng302.tab.service.UserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;

/**
 * Service class for {@link Challenge}s.
 */
@Service
public class ChallengeService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ChallengeService.class);
    public static final String INVALID_REQUEST_STRING = "Invalid request: {}";

    private final UserRepository userRepository;

    private final UserService userService;

    private final EventEmitter eventEmitter;

    /**
     * Repository access for challenges
     */
    private final ChallengeRepository challengeRepository;

    private final ChallengeGeneratorService generator;

    /**
     * Spring constructor for challenge service - do not call this directly; autowire or constructor
     * inject an instance of this class instead.
     *
     * @param challengeRepository The {@link #challengeRepository} for challenge persistence
     * @param userRepository      The {@link #userRepository} for user persistence
     * @param generator           The generator to use for making challenges
     * @param userService         The service to use for user operations
     */
    @Autowired
    public ChallengeService(
            ChallengeRepository challengeRepository,
            UserRepository userRepository,
            ChallengeGeneratorService generator,
            UserService userService,
            EventEmitter eventEmitter
    ) {
        this.challengeRepository = challengeRepository;
        this.userRepository = userRepository;
        this.generator = generator;
        this.userService = userService;
        this.eventEmitter = eventEmitter;
    }

    /**
     * Awards the hops for the given challenge to the given user if they exist in persistence and all
     * associated users have completed the challenge.
     *
     * @param challengeId the id of the challenge to award hops for
     * @param userId      the id of the user to award hops to
     * @return the number of hops awarded to all associated users if they have all completed the challenge, 0 otherwise
     */
    public synchronized int awardChallengeHops(Long challengeId, Long userId) {

        Challenge challengeForAward = this.getChallengeById(challengeId);
        UserEntity userForAward = userRepository.getUserById(userId);
        Set<ChallengeCompletionStatus> userCompletionStatuses = challengeForAward.getUserCompletionStatuses();

        if (userCompletionStatuses.stream().noneMatch(completion -> completion.getUser().equals(userForAward))) {
            throw new IllegalStateException("Tried to award hops for a challenge that wasn't allocated to user!");
        }

        if (challengeForAward.isComplete()) {
            throw new IllegalStateException("Tried to award hops for a challenge that was already completed!");
        }

        challengeForAward.completeForUser(userForAward); // marks challenge as complete overall if all users have completed it

        int hopsToAward = 0;
        if (challengeForAward.isComplete()) { // if all allocated users have completed the challenge
            hopsToAward = challengeForAward.getHops();
            challengeForAward.getUserGeneratedFor().addHops(hopsToAward);
            userRepository.save(challengeForAward.getUserGeneratedFor());
            for (UserEntity invitedUser : challengeForAward.getInvitedUsers()) {
                invitedUser.addHops(hopsToAward);
                userRepository.save(invitedUser);
            }
        }
        this.saveChallenge(challengeForAward);

        return hopsToAward;
    }

    /**
     * Gets all non-expired challenges that have been generated by a user that are not yet complete.
     * <p>
     * If the current set of incomplete challenges are all expired, then they are deleted and a new set
     * of challenges is generated for the user.
     *
     * @param user The user to find challenges for
     * @return Returns a list of all challenges that have been generated by the user that are not yet complete
     */
    public List<Challenge> getAllAvailableChallengesForUser(UserEntity user) {
        List<Challenge> userChallenges = challengeRepository.findChallengesForUser(user);

        if (userChallenges.isEmpty()) {
            return generator.generateChallengesForDay(user);
        }

        List<Challenge> allUnexpiredChallenges = userChallenges
                .stream()
                .filter(c -> !c.isExpired())
                .toList();

        if (allUnexpiredChallenges.isEmpty()) {
            challengeRepository.deleteAll(
                    userChallenges.stream()
                            .filter(Challenge::isExpired)
                            .filter(c -> !c.isComplete())
                            .toList()
            );
            return generator.generateChallengesForDay(user);
        }

        LOGGER.info("Returning existing challenges");
        return allUnexpiredChallenges.stream()
                .filter(c -> !c.isComplete())
                .toList();
    }

    /**
     * Gets all challenges for user that they have completed.
     *
     * @param user The user to get challenges for
     * @return Returns a potentially empty list of all challenges that the user has completed
     */
    public List<Challenge> getAllCompletedChallengesForUser(UserEntity user) {
        return challengeRepository.findChallengeByUserGeneratedForAndIsComplete(user, true);
    }

    /**
     * Gets a challenge by its ID
     *
     * @param challengeId The ID of the challenge to find
     * @return Returns the challenge with the given ID, or null if no such challenge exists
     */
    public Challenge getChallengeById(Long challengeId) {
        return challengeRepository.findChallengeById(challengeId);
    }

    /**
     * Saves a challenge to the repository
     *
     * @param challenge The challenge to save
     */
    public Challenge saveChallenge(Challenge challenge) {
        return challengeRepository.save(challenge);
    }

    public synchronized boolean tryCompleteChallenge(Long challengeId, UserEntity user) {
        try {
            awardChallengeHops(challengeId, user.getId());
        } catch (IllegalStateException | NullPointerException e) {
            LOGGER.error(INVALID_REQUEST_STRING, e.getMessage());
            return false;
        }
        return true;
    }

    /**
     * Invites users to a challenge if they are mutual followers of the logged-in user
     *
     * @param challenge The challenge to invite users to
     * @param users     The users to invite
     */
    public void inviteUsersToChallenge(Challenge challenge, List<UserEntity> users) {
        UserEntity loggedInUser = userService.getLoggedInUser();

        List<UserEntity> filteredUsers = users.stream().filter(user ->
                loggedInUser.getFollowing().contains(user) &&
                        user.getFollowing().contains(loggedInUser)
        ).toList();

        challenge.inviteUsers(filteredUsers);
        challenge.updateHopsForSharedChallenge();
        challengeRepository.save(challenge);

        emitNotificationEvent(challenge.getId(), filteredUsers);
    }

    /**
     * Emits a notification event for a challenge being shared.
     *
     * @param challengeId The ID of the challenge that was shared.
     * @param users       The users that were invited to the challenge.
     */
    void emitNotificationEvent(Long challengeId, List<UserEntity> users) {
        LOGGER.info("Emitting challenge shared event");
        ChallengeSharedEvent event = new ChallengeSharedEvent();
        event.setChallengeId(challengeId);
        event.setInvitedUsers(users);
        event.setRelatedUser(challengeRepository.findChallengeById(challengeId).getUserGeneratedFor());
        eventEmitter.emit(event);
    }


}
