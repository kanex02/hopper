package nz.ac.canterbury.seng302.tab.entity.challenge;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import nz.ac.canterbury.seng302.tab.entity.UserEntity;
import org.hibernate.validator.constraints.Range;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.Nullable;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Represents a challenge for a user.
 */
@Entity(name = "challenge")
@SuppressWarnings("unused") // suppressed as getters are used by Thymeleaf
@JsonIdentityInfo(
        generator = ObjectIdGenerators.PropertyGenerator.class,
        property = "id"
)
public class Challenge {

    private static final Logger LOGGER = LoggerFactory.getLogger(Challenge.class);

    /**
     * Regular expression that {@link #title} must conform to.
     * Titles must have at least one character, and not end in whitespace.
     */
    public static final String TITLE_PATTERN = "^(\\p{javaSpaceChar}|\\p{L})+$";
    /**
     * Error message to be returned when {@link #title} does not match {@link #TITLE_PATTERN}.
     */
    public static final String TITLE_ERROR_MESSAGE = "Challenge title must be at least 3 chars long as well as consist of only: alphanumeric characters, dots, and curly braces";
    /**
     * The minimum inclusive value that {@link #hops} may be allowed to take
     */
    public static final int HOPS_LOWER_BOUND = 30;
    /**
     * The maximum inclusive value that {@link #hops} may be allowed to take
     */
    public static final int HOPS_UPPER_BOUND = 50;
    /**
     * The maximum length of the {@link #title}.
     * <p>
     * Maximum length is needed for the VARCHAR column.
     */
    public static final int TITLE_MAX_LENGTH = 50;
    /**
     * The maximum length of the {@link #goal}
     * <p>
     * Maximum length is needed for the VARCHAR column.
     */
    public static final int GOAL_MAX_LENGTH = 255;

    /**
     * The generated ID of the challenge. Value is generated by JPA and is null until saved.
     */
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    private Long id;

    /**
     * The date that the challenge expires on.
     */
    @Column(nullable = false)
    @NotNull
    private LocalDateTime endDate;

    /**
     * The date that the challenge was marked as complete for all associated users.
     */
    @Column
    private LocalDateTime completedDate;

    /**
     * The title of the challenge. Must be a non-null, non-empty string that conforms to
     * {@link #TITLE_PATTERN}.
     */
    @Column(nullable = false, length = TITLE_MAX_LENGTH)
    @NotNull
    @Size(min = 1, max = TITLE_MAX_LENGTH)
    @Pattern(regexp = TITLE_PATTERN, message = TITLE_ERROR_MESSAGE)
    private String title;

    /**
     * The goal of the challenge, sort of like a description.
     * Must be a non-null, non-empty string with a maximum length of {@value #GOAL_MAX_LENGTH}.
     */
    @Column(nullable = false)
    @NotNull
    @Size(min = 1, max = GOAL_MAX_LENGTH)
    private String goal;

    /**
     * The XP (Hops) gained from completing this challenge.
     * <p>
     * Must be a value between {@value #HOPS_LOWER_BOUND} (inclusive) and {@value #HOPS_UPPER_BOUND} (inclusive)
     */
    @Range(min = HOPS_LOWER_BOUND, max = HOPS_UPPER_BOUND)
    private int hops;

    /**
     * The user that the challenge was generated for.
     * <p>
     * Cannot be null.
     */
    @ManyToOne
    @NotNull
    private UserEntity userGeneratedFor;

    /**
     * The set of {@link ChallengeCompletionStatus}es for this challenge.
     */
    @OneToMany(mappedBy = "challenge", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    private final Set<ChallengeCompletionStatus> userCompletionStatuses = new HashSet<>();

    /**
     * Flag to check if <b>all</b> associated users have completed this challenge, defaults to false on creation.
     */
    private boolean isComplete;

    /**
     * Default no-args constructor for JPA. Do not call this! Most values will not be valid!
     */
    protected Challenge() {
    }

    /**
     * Normal Constructor for challenges. Accept values for end date, title, goal, and hops.
     *
     * @param endDate The {@link #endDate}
     * @param title   The {@link #title}
     * @param goal    The {@link #goal}
     * @param hops    The {@link #hops}
     */
    public Challenge(UserEntity userGeneratedFor, LocalDateTime endDate, String title, String goal, int hops) {
        this.userGeneratedFor = userGeneratedFor;
        this.endDate = endDate;
        this.title = title == null ? null : title.strip();
        this.goal = goal == null ? null : goal.strip();
        this.hops = hops;
        this.userCompletionStatuses.add(new ChallengeCompletionStatus(this, userGeneratedFor, false));
    }

    /**
     * Getter for {@link #id}. This value will be {@code null} if the object was instantiated directly and not
     * retrieved from the database.
     *
     * @return Returns the ID of the challenge.
     */
    @Nullable
    public Long getId() {
        return id;
    }

    /**
     * Getter for {@link #title}.
     *
     * @return Returns the title of the challenge.
     */
    public String getTitle() {
        return title;
    }

    /**
     * Getter for {@link #endDate}.
     *
     * @return Returns the end date of the challenge.
     */
    public LocalDateTime getEndDate() {
        return endDate;
    }

    /**
     * Getter for {@link #goal}.
     *
     * @return Returns the goal of the challenge.
     */
    public String getGoal() {
        return goal;
    }

    /**
     * Getter for {@link #hops}.
     *
     * @return Returns the hops reward of the challenge.
     */
    public int getHops() {
        return hops;
    }

    public void setHops(int hops) {
        this.hops = hops;
    }

    /**
     * Getter for {@link #userGeneratedFor}.
     *
     * @return Returns the user that the challenge was generated for.
     */
    public UserEntity getUserGeneratedFor() {
        return userGeneratedFor;
    }

    /**
     * Getter for {@link #isComplete}.
     *
     * @return Returns true if the challenge has been completed, false otherwise.
     */
    public boolean isComplete() {
        return isComplete;
    }

    /**
     * Getter for {@link #completedDate}.
     * @return Returns the date that the challenge was completed on.
     */
    public LocalDateTime getCompletedDate() {
        return completedDate;
    }

    /**
     * Setter for {@link #completedDate}.
     * @param completedDate The date that the challenge was completed on.
     */
    public void setCompletedDate(LocalDateTime completedDate) {
        this.completedDate = completedDate;
    }

    /**
     * Checks if the current time (in UTC) is after the end date of the challenge.
     *
     * @return Returns true if the challenge is expired
     */
    public boolean isExpired() {
        return LocalDateTime.now(ZoneOffset.UTC).isAfter(this.endDate);
    }

    public boolean isShared() {
        return this.userCompletionStatuses.size() > 1;
    }

    public boolean isWaitingOnOtherUsers(UserEntity user) {
        return !this.isComplete && this.isChallengeCompleteForUser(user) && this.userCompletionStatuses.size() > 1;
    }

    /**
     * Marks the challenge as complete if not already complete. If the challenge has already been completed,
     * throws an {@link IllegalStateException}.
     * Note: this should only be called if all associated users have completed the challenge.
     * <p>
     * Post condition: {@link #isComplete} is true.
     *
     * @throws IllegalStateException Thrown if attempting to complete an already completed challenge
     */
    public void complete() throws IllegalStateException {
        this.complete(null);
    }

    /**
     * Marks the challenge as complete if not already complete. If the challenge has already been completed,
     * throws an {@link IllegalStateException}.
     * Note: this should only be called if all associated users have completed the challenge.
     * <p>
     * Post condition: {@link #isComplete} is true.
     *
     * @param onCompleteCallback Invoked when this challenge is successfully completed - may be null.
     * @throws IllegalStateException Thrown if attempting to complete an already completed challenge
     */
    public void complete(@Nullable Consumer<Challenge> onCompleteCallback) throws IllegalStateException {
        if (!isComplete && completedDate == null) {
            isComplete = true;
            completedDate = LocalDateTime.now(ZoneOffset.UTC);
            if (onCompleteCallback != null) {
                onCompleteCallback.accept(this);
            }
        } else {
            throw new IllegalStateException("Cannot complete an already completed challenge");
        }
    }

    /**
     * Checks that this challenge is equal to another object.
     * <p>
     * Two challenges are equal if and only if all their fields are equals, except for user where equality is checked by
     * id instead of the {@code equals()} method.
     *
     * @param o The other object to check equality against
     * @return Returns true if the two objects are equal
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Challenge challenge = (Challenge) o;
        return hops == challenge.hops
                && isComplete == challenge.isComplete
                && Objects.equals(id, challenge.id)
                && endDate.equals(challenge.endDate)
                && title.equals(challenge.title)
                && goal.equals(challenge.goal)
                && Objects.equals(userGeneratedFor.getId(), challenge.userGeneratedFor.getId());
    }

    /**
     * Hashes the challenge based on its fields
     *
     * @return Returns the hash code of the challenge
     */
    @Override
    public int hashCode() {
        return Objects.hash(id, endDate, title, goal, hops, userGeneratedFor, isComplete);
    }

    /**
     * Adds a list of users to allocate this challenge to.
     * @param users The list of users to add
     */
    public void inviteUsers(List<UserEntity> users) {
        users.stream().map(user -> new ChallengeCompletionStatus(this, user, false)).forEach(userCompletionStatuses::add);
    }

    /**
     * Gets the list of users that this challenge has been shared to.
     * @return Returns the list of users that this challenge has been shared to.
     */
    public List<UserEntity> getInvitedUsers() {
        return userCompletionStatuses.stream()
                .map(ChallengeCompletionStatus::getUser)
                .filter(user -> !user.equals(userGeneratedFor))
                .toList();
    }

    public Set<ChallengeCompletionStatus> getUserCompletionStatuses() {
        return this.userCompletionStatuses;
    }

    /**
     * Attempts to mark this challenge as complete for a given user. If afterwards all associated users have completed
     * the challenge, marks the challenge as complete.
     *
     * @param userForAward The user to mark the challenge as complete for
     * @throws IllegalStateException if the challenge is not allocated to the given user
     */
    public void completeForUser(UserEntity userForAward) throws IllegalStateException {

        if (this.userCompletionStatuses.stream().noneMatch(completion -> completion.getUser().equals(userForAward))) {
            throw new IllegalStateException("Tried to award hops for a challenge that wasn't allocated to user!");
        }

        // mark complete for userForAward
        this.userCompletionStatuses.stream()
                .filter(completion -> completion.getUser().equals(userForAward))
                .findFirst()
                .ifPresent(completion -> completion.setCompleted(true));

        if (this.userCompletionStatuses.stream().allMatch(ChallengeCompletionStatus::isCompleted)) {
            this.complete(c -> {
                if (c.getTitle().equals("Brew Coffee")) {
                    throw new IsTeaPotException();
                }
            }); // marking the challenge as complete if all associated users have completed it
        }
    }

    /**
     * Checks if the challenge is complete for a given user.
     *
     * @param originalUser The user to check if the challenge is complete for
     * @return true if the challenge is complete for the given user, false otherwise
     */
    public boolean isChallengeCompleteForUser(UserEntity originalUser) {
        boolean result = this.userCompletionStatuses.stream()
                .filter(completion -> completion.getUser().equals(originalUser))
                .findFirst()
                .map(ChallengeCompletionStatus::isCompleted)
                .orElse(false);
        LOGGER.debug("isChallengeCompleteForUser: {}", result);
        return result;
    }

    public void updateHopsForSharedChallenge() {
        if (isShared()) {
            int newHops = Math.round(getHops() * 1.2f);
            setHops(newHops);
        }
    }

}
